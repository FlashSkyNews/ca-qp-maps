<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
        <meta name="description"
              content="BlueMap is a tool that generates 3D maps of your Minecraft worlds and displays them in your browser">
        <meta name="version" content="5.13">
        <meta name="keywords" content="bluemap, map, minecraft, minecraft map">
        <meta name="theme-color" content="#006EDE">
        <meta name="og:site_name" content="BlueMap">
        <meta name="og:title" content="BlueMap">
        <meta name="og:description"
              content="BlueMap is a tool that generates 3D maps of your Minecraft worlds and displays them in your browser">
        <meta name="og:type" content="website">
        <meta name="og:image" content="https://avatars.githubusercontent.com/u/42522657?s=200&v=4">
        <meta name="robots" content="index,nofollow">
        <link rel="icon" href="./assets/favicon-DEN7TZ5X.png">
        <link rel="manifest" href="./assets/manifest-vz4Wm4Dd.webmanifest">
        <title>BlueMap</title>
      <script>
        // AGGRESSIVE: Stop BlueMap from polling static data every second
        (function() {
          'use strict';
          
          // Cache for live data - return immediately without network request
          const liveDataCache = new Map();
          const emptyLiveData = '{}';
          
          // Override fetch - intercept ALL requests
          const originalFetch = window.fetch;
          window.fetch = function(...args) {
            const url = args[0];
            const options = args[1] || {};
            
            // FORCE cache for live data - return cached empty response immediately
            if (typeof url === 'string') {
              if (url.includes('/live/players.json') || url.includes('/live/markers.json')) {
                // Return cached empty response immediately - NO NETWORK REQUEST
                if (!liveDataCache.has(url)) {
                  liveDataCache.set(url, emptyLiveData);
                }
                return Promise.resolve(new Response(liveDataCache.get(url), {
                  status: 200,
                  headers: {
                    'Content-Type': 'application/json',
                    'Cache-Control': 'public, max-age=31536000, immutable'
                  }
                }));
              }
              
              // Force cache for all other static assets
              options.cache = options.cache || 'default';
            }
            
            return originalFetch.apply(this, arguments).then(response => {
              // Convert 404 tile responses to empty 200
              if (response.status === 404 && typeof url === 'string' && url.includes('/tiles/')) {
                const contentType = url.endsWith('.png') ? 'image/png' : 'application/octet-stream';
                return new Response(new Uint8Array(0), {
                  status: 200,
                  headers: { 'Content-Type': contentType }
                });
              }
              return response;
            }).catch(err => {
              if (typeof url === 'string' && url.includes('/tiles/')) {
                const contentType = url.endsWith('.png') ? 'image/png' : 'application/octet-stream';
                return new Response(new Uint8Array(0), {
                  status: 200,
                  headers: { 'Content-Type': contentType }
                });
              }
              throw err;
            });
          };
          
          // Override XMLHttpRequest - BlueMap might use this too
          const originalXHROpen = XMLHttpRequest.prototype.open;
          const originalXHRSend = XMLHttpRequest.prototype.send;
          
          XMLHttpRequest.prototype.open = function(method, url, ...rest) {
            this._bluemapUrl = url;
            this._bluemapMethod = method;
            return originalXHROpen.apply(this, [method, url, ...rest]);
          };
          
          XMLHttpRequest.prototype.send = function(...args) {
            const url = this._bluemapUrl;
            
            // Intercept live data requests - return immediately without network
            if (url && typeof url === 'string' && 
                (url.includes('/live/players.json') || url.includes('/live/markers.json'))) {
              
              // Set up fake successful response
              setTimeout(() => {
                Object.defineProperty(this, 'status', { value: 200, writable: false, configurable: true });
                Object.defineProperty(this, 'statusText', { value: 'OK', writable: false, configurable: true });
                Object.defineProperty(this, 'responseText', { value: emptyLiveData, writable: false, configurable: true });
                Object.defineProperty(this, 'response', { value: emptyLiveData, writable: false, configurable: true });
                Object.defineProperty(this, 'readyState', { value: 4, writable: false, configurable: true });
                
                // Trigger events
                if (this.onreadystatechange) this.onreadystatechange();
                if (this.onload) this.onload();
                this.dispatchEvent(new Event('load'));
                this.dispatchEvent(new Event('readystatechange'));
              }, 0);
              
              return; // Don't actually send the request
            }
            
            return originalXHRSend.apply(this, args);
          };
          
          // Also intercept any setInterval that might be polling
          const originalSetInterval = window.setInterval;
          window.setInterval = function(callback, delay, ...args) {
            // If it's polling every second (1000ms), check if it's for live data
            if (delay === 1000 || delay === 1001 || delay === 999) {
              const wrappedCallback = function() {
                // Check if callback tries to fetch live data - if so, skip it
                const originalFetch = window.fetch;
                let fetchCalled = false;
                let fetchUrl = null;
                
                window.fetch = function(...fetchArgs) {
                  fetchCalled = true;
                  fetchUrl = fetchArgs[0];
                  return originalFetch.apply(this, fetchArgs);
                };
                
                try {
                  callback.apply(this, arguments);
                } finally {
                  window.fetch = originalFetch;
                  
                  // If it was trying to fetch live data, don't run the callback
                  if (fetchCalled && fetchUrl && typeof fetchUrl === 'string' && 
                      (fetchUrl.includes('/live/players.json') || fetchUrl.includes('/live/markers.json'))) {
                    return; // Skip this polling cycle
                  }
                }
              };
              return originalSetInterval(wrappedCallback, delay, ...args);
            }
            return originalSetInterval(callback, delay, ...args);
          };
          
          console.log('BlueMap static map: Live polling disabled, all requests cached');
        })();
      </script>
      <script type="module" crossorigin src="./assets/index-ZbCQNBFs.js"></script>
      <link rel="stylesheet" crossorigin href="./assets/index-BgiqB2rB.css">
    </head>
    <body>
        <noscript>
            <strong>Sorry but BlueMap doesn't work without JavaScript enabled.
                Please <a href="https://www.enable-javascript.com/">enable</a> it to continue.</strong>
        </noscript>
        <div id="map-container"></div>
        <div id="app"></div>
    </body>
</html>
